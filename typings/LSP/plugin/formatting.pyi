import sublime
from .core.collections import DottedDict as DottedDict
from .core.edit import apply_text_edits as apply_text_edits
from .core.promise import Promise as Promise
from .core.protocol import Error as Error, TextDocumentSaveReason as TextDocumentSaveReason, TextEdit as TextEdit
from .core.registry import LspTextCommand as LspTextCommand, windows as windows
from .core.sessions import Session as Session
from .core.settings import userprefs as userprefs
from .core.views import entire_content_region as entire_content_region, first_selection_region as first_selection_region, has_single_nonempty_selection as has_single_nonempty_selection, text_document_formatting as text_document_formatting, text_document_range_formatting as text_document_range_formatting, text_document_ranges_formatting as text_document_ranges_formatting, will_save_wait_until as will_save_wait_until
from .save_command import LspSaveCommand as LspSaveCommand, SaveTask as SaveTask
from _typeshed import Incomplete
from typing import Callable

FormatResponse = list[TextEdit] | None | Error

def get_formatter(window: sublime.Window | None, base_scope: str) -> str | None: ...
def format_document(text_command: LspTextCommand, formatter: str | None = None) -> Promise[FormatResponse]: ...

class WillSaveWaitTask(SaveTask):
    @classmethod
    def is_applicable(cls, view: sublime.View) -> bool: ...
    _session_iterator: Incomplete
    def __init__(self, task_runner: LspTextCommand, on_complete: Callable[[], None]) -> None: ...
    def run_async(self) -> None: ...
    def _handle_next_session_async(self) -> None: ...
    def _will_save_wait_until_async(self, session: Session) -> None: ...
    def _on_response(self, response: FormatResponse) -> None: ...

class FormattingTask(SaveTask):
    @classmethod
    def is_applicable(cls, view: sublime.View) -> bool: ...
    def run_async(self) -> None: ...
    def _on_response(self, response: FormatResponse) -> None: ...

class LspFormatDocumentCommand(LspTextCommand):
    capability: str
    def is_enabled(self, event: dict | None = None, select: bool = False) -> bool: ...
    def run(self, edit: sublime.Edit, event: dict | None = None, select: bool = False) -> None: ...
    def on_result(self, result: FormatResponse) -> None: ...
    def select_formatter(self, base_scope: str, session_names: list[str]) -> None: ...
    def on_select_formatter(self, base_scope: str, session_names: list[str], index: int) -> None: ...

class LspFormatDocumentRangeCommand(LspTextCommand):
    capability: str
    def is_enabled(self, event: dict | None = None, point: int | None = None) -> bool: ...
    def run(self, edit: sublime.Edit, event: dict | None = None) -> None: ...

class LspFormatCommand(LspTextCommand):
    def is_enabled(self, event: dict | None = None, point: int | None = None) -> bool: ...
    def is_visible(self, event: dict | None = None, point: int | None = None) -> bool: ...
    def description(self, **kwargs) -> str: ...
    def run(self, edit: sublime.Edit, event: dict | None = None) -> None: ...
    def _range_formatting_available(self) -> bool: ...
