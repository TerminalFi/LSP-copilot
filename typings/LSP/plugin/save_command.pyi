import sublime
import sublime_plugin
from .core.registry import LspTextCommand as LspTextCommand
from .core.settings import userprefs as userprefs
from _typeshed import Incomplete
from abc import ABCMeta, abstractmethod
from typing import Any, Callable

class SaveTask(metaclass=ABCMeta):
    @classmethod
    @abstractmethod
    def is_applicable(cls, view: sublime.View) -> bool: ...
    _task_runner: Incomplete
    _on_done: Incomplete
    _completed: bool
    _cancelled: bool
    _status_key: Incomplete
    def __init__(self, task_runner: LspTextCommand, on_done: Callable[[], None]) -> None: ...
    def run_async(self) -> None: ...
    def _on_timeout(self) -> None: ...
    def cancel(self) -> None: ...
    def _set_view_status(self, text: str) -> None: ...
    def _erase_view_status(self) -> None: ...
    def _on_complete(self) -> None: ...
    def _purge_changes_async(self) -> None: ...

class SaveTasksRunner:
    _text_command: Incomplete
    _tasks: Incomplete
    _on_tasks_completed: Incomplete
    _pending_tasks: Incomplete
    _canceled: bool
    def __init__(self, text_command: LspTextCommand, tasks: list[type[SaveTask]], on_complete: Callable[[], None]) -> None: ...
    def run(self) -> None: ...
    def cancel(self) -> None: ...
    def _process_next_task(self) -> None: ...
    def _run_next_task_async(self) -> None: ...
    def _on_task_completed_async(self) -> None: ...

class LspSaveCommand(LspTextCommand):
    _tasks: list[type[SaveTask]]
    @classmethod
    def register_task(cls, task: type[SaveTask]) -> None: ...
    _save_tasks_runner: Incomplete
    def __init__(self, view: sublime.View) -> None: ...
    def run(self, edit: sublime.Edit, **kwargs: dict[str, Any]) -> None: ...
    def _trigger_on_pre_save_async(self) -> None: ...
    def _on_tasks_completed(self, kwargs: dict[str, Any]) -> None: ...

class LspSaveAllCommand(sublime_plugin.WindowCommand):
    def run(self, only_files: bool = False) -> None: ...
