import sublime
import weakref
from .core.constants import COMPLETION_KINDS as COMPLETION_KINDS
from .core.edit import apply_text_edits as apply_text_edits
from .core.logging import debug as debug
from .core.promise import Promise as Promise
from .core.protocol import CompletionItem as CompletionItem, CompletionItemDefaults as CompletionItemDefaults, CompletionItemKind as CompletionItemKind, CompletionItemTag as CompletionItemTag, CompletionList as CompletionList, CompletionParams as CompletionParams, EditRangeWithInsertReplace as EditRangeWithInsertReplace, Error as Error, InsertReplaceEdit as InsertReplaceEdit, InsertTextFormat as InsertTextFormat, MarkedString as MarkedString, MarkupContent as MarkupContent, MarkupKind as MarkupKind, Range as Range, Request as Request, TextEdit as TextEdit
from .core.registry import LspTextCommand as LspTextCommand
from .core.sessions import Session as Session
from .core.settings import userprefs as userprefs
from .core.views import FORMAT_MARKUP_CONTENT as FORMAT_MARKUP_CONTENT, FORMAT_STRING as FORMAT_STRING, MarkdownLangMap as MarkdownLangMap, minihtml as minihtml, range_to_region as range_to_region, show_lsp_popup as show_lsp_popup, text_document_position_params as text_document_position_params, update_lsp_popup as update_lsp_popup
from _typeshed import Incomplete
from typing import Any, Callable, Generator
from typing_extensions import TypeAlias, TypeGuard

SessionName: TypeAlias
CompletionResponse: TypeAlias
ResolvedCompletions: TypeAlias
CompletionsStore: TypeAlias

def format_details(detail: str, cutoff_length: int = 80) -> str: ...
def format_completion(item: CompletionItem, index: int, can_resolve_completion_items: bool, session_name: str, item_defaults: CompletionItemDefaults, view_id: int) -> sublime.CompletionItem: ...
def get_text_edit_range(text_edit: TextEdit | InsertReplaceEdit) -> Range: ...
def is_range(val: Any) -> TypeGuard[Range]: ...
def is_edit_range(val: Any) -> TypeGuard[EditRangeWithInsertReplace]: ...
def completion_with_defaults(item: CompletionItem, item_defaults: CompletionItemDefaults) -> CompletionItem: ...

class QueryCompletionsTask:
    _view: Incomplete
    _location: Incomplete
    _triggered_manually: Incomplete
    _on_done_async: Incomplete
    _resolved: bool
    _pending_completion_requests: Incomplete
    def __init__(self, view: sublime.View, location: int, triggered_manually: bool, on_done_async: Callable[[list[sublime.CompletionItem], sublime.AutoCompleteFlags], None]) -> None: ...
    def query_completions_async(self, sessions: list[Session]) -> None: ...
    def _create_completion_request_async(self, session: Session) -> Promise[ResolvedCompletions]: ...
    def _on_completion_response_async(self, response: CompletionResponse, request_id: int, weak_session: weakref.ref[Session]) -> ResolvedCompletions: ...
    def _resolve_completions_async(self, responses: list[ResolvedCompletions]) -> None: ...
    def cancel_async(self) -> None: ...
    def _cancel_pending_requests_async(self) -> None: ...
    def _resolve_task_async(self, completions: list[sublime.CompletionItem], flags: sublime.AutoCompleteFlags) -> None: ...
    def _get_userpref_flags(self) -> sublime.AutoCompleteFlags: ...

class LspResolveDocsCommand(LspTextCommand):
    def run(self, edit: sublime.Edit, index: int, session_name: str, event: dict | None = None) -> None: ...
    def _handle_resolve_response_async(self, language_map: MarkdownLangMap | None, item: CompletionItem) -> None: ...
    def _format_documentation(self, content: MarkedString | MarkupContent, language_map: MarkdownLangMap | None) -> str: ...
    def _on_navigate(self, url: str) -> None: ...

class LspCommitCompletionWithOppositeInsertMode(LspTextCommand):
    active: bool
    def run(self, edit: sublime.Edit, event: dict | None = None) -> None: ...

class LspSelectCompletionCommand(LspTextCommand):
    completions: dict[SessionName, CompletionsStore]
    def run(self, edit: sublime.Edit, index: int, session_name: str) -> None: ...
    def want_event(self) -> bool: ...
    def _on_resolved_async(self, session_name: str, item: CompletionItem) -> None: ...
    def _on_resolved(self, session_name: str, item: CompletionItem) -> None: ...
    def _translated_regions(self, edit_region: sublime.Region) -> Generator[sublime.Region, None, None]: ...
