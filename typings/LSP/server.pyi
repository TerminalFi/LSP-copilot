import asyncio
from _typeshed import Incomplete
from enum import IntEnum
from typing import Any, Awaitable, Callable

__package__: str
__version__: str
StringDict = dict[str, Any]
PayloadLike = list[StringDict] | StringDict | None
ENCODING: str

class ErrorCode(IntEnum):
    ParseError = -32700
    InvalidRequest = -32600
    MethodNotFound = -32601
    InvalidParams = -32602
    InternalError = -32603
    serverErrorStart = -32099
    serverErrorEnd = -32000
    ServerNotInitialized = -32002
    UnknownErrorCode = -32001
    RequestCancelled = -32800
    ContentModified = -32801

class Error(Exception):
    code: Incomplete
    def __init__(self, code: ErrorCode, message: str) -> None: ...
    def to_lsp(self) -> StringDict: ...
    @classmethod
    def from_lsp(cls, d: StringDict) -> Error: ...
    def __str__(self) -> str: ...

def jsonrpc() -> StringDict: ...
def make_response(request_id: Any, params: PayloadLike) -> StringDict: ...
def make_error_response(request_id: Any, err: Error) -> StringDict: ...
def make_notification(method: str, params: PayloadLike) -> StringDict: ...
def make_request(method: str, request_id: Any, params: PayloadLike) -> StringDict: ...
def dump(payload: PayloadLike) -> bytes: ...
def content_length(line: bytes) -> int | None: ...

class MessageType:
    error: int
    warning: int
    info: int
    log: int

class StopLoopException(Exception): ...

class Request:
    async def on_error(self, err: Error) -> None: ...
    async def on_result(self, params: PayloadLike) -> None: ...

class SimpleRequest(Request):
    cv: Incomplete
    result: Incomplete
    error: Incomplete
    def __init__(self) -> None: ...
    async def on_result(self, params: PayloadLike) -> None: ...
    async def on_error(self, err: Error) -> None: ...

class Session:
    _reader: Incomplete
    _writer: Incomplete
    _response_handlers: Incomplete
    _request_handlers: Incomplete
    _notification_handlers: Incomplete
    _received_shutdown: bool
    _responses: Incomplete
    _received: Incomplete
    _received_cv: Incomplete
    def __init__(self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter) -> None: ...
    def _log(self, message: str) -> None: ...
    def _notify(self, method: str, params: PayloadLike) -> None: ...
    def _reply(self, request_id: Any, params: PayloadLike) -> None: ...
    def _error(self, request_id: Any, err: Error) -> None: ...
    async def request(self, method: str, params: PayloadLike) -> PayloadLike: ...
    async def _send_payload(self, payload: StringDict) -> None: ...
    async def _receive_payload(self, payload: StringDict) -> None: ...
    async def _response_handler(self, response: StringDict) -> None: ...
    def _on_request(self, request_method: str, handler: Callable[[PayloadLike], Awaitable[PayloadLike]]) -> None: ...
    def _on_notification(self, notification_method: str, handler: Callable[[PayloadLike], Awaitable[None]]) -> None: ...
    async def _handle(self, typestr: str, message: dict[str, Any], handlers: dict[str, Callable], request_id: int | None) -> None: ...
    def _get_mocked_response(self, method: str) -> PayloadLike | bool: ...
    async def _handle_body(self, body: bytes) -> None: ...
    async def run_forever(self) -> bool: ...
    def _install_handlers(self) -> None: ...
    async def _on_set_response(self, params: PayloadLike) -> None: ...
    async def _set_responses(self, params: PayloadLike) -> PayloadLike: ...
    async def _send_notification(self, params: PayloadLike) -> PayloadLike: ...
    async def _get_received(self, params: PayloadLike) -> PayloadLike: ...
    async def _fake_request(self, params: PayloadLike) -> PayloadLike: ...
    def _validate_request_params(self, params: PayloadLike) -> tuple[str, dict | list | None]: ...
    async def _initialize(self, params: PayloadLike) -> PayloadLike: ...
    async def _shutdown(self, params: PayloadLike) -> PayloadLike: ...
    async def _on_exit(self, params: PayloadLike) -> None: ...

async def stdio() -> tuple[asyncio.StreamReader, asyncio.StreamWriter]: ...
async def _unix_stdio(loop: asyncio.AbstractEventLoop) -> tuple[asyncio.StreamReader, asyncio.StreamWriter]: ...
def _win32_stdio(loop: asyncio.AbstractEventLoop) -> tuple[asyncio.StreamReader, asyncio.StreamWriter]: ...
async def main(tcp_port: int | None = None) -> bool: ...
