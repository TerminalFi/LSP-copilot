from .types import Array as Array, ArrayLike as ArrayLike, Matrix as Matrix, MatrixLike as MatrixLike, SupportsFloatOrInt as SupportsFloatOrInt, Vector as Vector, VectorLike as VectorLike
from _typeshed import Incomplete
from typing import Callable, Iterator, Sequence, overload

NaN: Incomplete
INF: Incomplete
PY38: Incomplete
prod: Incomplete
SC: Incomplete
D1: Incomplete
D2: Incomplete
SC_D1: Incomplete
SC_D2: Incomplete
D1_SC: Incomplete
D1_D2: Incomplete
D2_SC: Incomplete
D2_D1: Incomplete
DN_DM: Incomplete
M141: Incomplete

def is_nan(obj: float) -> bool: ...
def no_nans(value: VectorLike, default: float = 0.0) -> Vector: ...
def no_nan(value: float, default: float = 0.0) -> float: ...
def round_half_up(n: float, scale: int = 0) -> float: ...
def round_to(f: float, p: int = 0) -> float: ...
def clamp(value: SupportsFloatOrInt, mn: SupportsFloatOrInt | None = None, mx: SupportsFloatOrInt | None = None) -> SupportsFloatOrInt: ...
def cbrt(n: float) -> float: ...
def nth_root(n: float, p: float) -> float: ...
def npow(base: float, exp: float) -> float: ...
def lerp(p0: float, p1: float, t: float) -> float: ...
def naturalize_bspline_controls(coordinates: list[Vector]) -> None: ...
def bspline(p0: float, p1: float, p2: float, p3: float, t: float) -> float: ...
def catrom(p0: float, p1: float, p2: float, p3: float, t: float) -> float: ...
def monotone(p0: float, p1: float, p2: float, p3: float, t: float) -> float: ...

SPLINES: dict[str, Callable[..., float]]

class Interpolate:
    length: Incomplete
    num_coords: Incomplete
    points: Incomplete
    callback: Incomplete
    linear: Incomplete
    def __init__(self, points: list[Vector], callback: Callable[..., float], length: int, linear: bool = False) -> None: ...
    def steps(self, count: int) -> list[Vector]: ...
    def __call__(self, t: float) -> Vector: ...

def interpolate(points: list[Vector], method: str = 'linear') -> Interpolate: ...
def vdot(a: VectorLike, b: VectorLike) -> float: ...
def vcross(v1: VectorLike, v2: VectorLike) -> Vector: ...
@overload
def acopy(a: VectorLike) -> Vector: ...
@overload
def acopy(a: MatrixLike) -> Matrix: ...
@overload
def cross(a: VectorLike, b: VectorLike) -> Vector: ...
@overload
def cross(a: MatrixLike, b: VectorLike | MatrixLike) -> Matrix: ...
@overload
def cross(a: VectorLike | MatrixLike, b: MatrixLike) -> Matrix: ...
@overload
def dot(a: float, b: float, *, dims: tuple[int, int] | None = None) -> float: ...
@overload
def dot(a: float, b: VectorLike, *, dims: tuple[int, int] | None = None) -> Vector: ...
@overload
def dot(a: VectorLike, b: float, *, dims: tuple[int, int] | None = None) -> Vector: ...
@overload
def dot(a: float, b: MatrixLike, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def dot(a: MatrixLike, b: float, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def dot(a: VectorLike, b: VectorLike, *, dims: tuple[int, int] | None = None) -> float: ...
@overload
def dot(a: VectorLike, b: MatrixLike, *, dims: tuple[int, int] | None = None) -> Vector: ...
@overload
def dot(a: MatrixLike, b: VectorLike, *, dims: tuple[int, int] | None = None) -> Vector: ...
@overload
def dot(a: MatrixLike, b: MatrixLike, *, dims: tuple[int, int] | None = None) -> Matrix: ...
def multi_dot(arrays: Sequence[ArrayLike]) -> float | Array: ...
@overload
def divide(a: float, b: float, *, dims: tuple[int, int] | None = None) -> float: ...
@overload
def divide(a: float, b: VectorLike, *, dims: tuple[int, int] | None = None) -> Vector: ...
@overload
def divide(a: VectorLike, b: float, *, dims: tuple[int, int] | None = None) -> Vector: ...
@overload
def divide(a: float, b: MatrixLike, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def divide(a: MatrixLike, b: float, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def divide(a: VectorLike, b: VectorLike, *, dims: tuple[int, int] | None = None) -> Vector: ...
@overload
def divide(a: VectorLike, b: MatrixLike, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def divide(a: MatrixLike, b: VectorLike, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def divide(a: MatrixLike, b: MatrixLike, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def multiply(a: float, b: float, *, dims: tuple[int, int] | None = None) -> float: ...
@overload
def multiply(a: float, b: VectorLike, *, dims: tuple[int, int] | None = None) -> Vector: ...
@overload
def multiply(a: VectorLike, b: float, *, dims: tuple[int, int] | None = None) -> Vector: ...
@overload
def multiply(a: float, b: MatrixLike, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def multiply(a: MatrixLike, b: float, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def multiply(a: VectorLike, b: VectorLike, *, dims: tuple[int, int] | None = None) -> Vector: ...
@overload
def multiply(a: VectorLike, b: MatrixLike, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def multiply(a: MatrixLike, b: VectorLike, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def multiply(a: MatrixLike, b: MatrixLike, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def add(a: float, b: float, *, dims: tuple[int, int] | None = None) -> float: ...
@overload
def add(a: float, b: VectorLike, *, dims: tuple[int, int] | None = None) -> Vector: ...
@overload
def add(a: VectorLike, b: float, *, dims: tuple[int, int] | None = None) -> Vector: ...
@overload
def add(a: float, b: MatrixLike, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def add(a: MatrixLike, b: float, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def add(a: VectorLike, b: VectorLike, *, dims: tuple[int, int] | None = None) -> Vector: ...
@overload
def add(a: VectorLike, b: MatrixLike, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def add(a: MatrixLike, b: VectorLike, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def add(a: MatrixLike, b: MatrixLike, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def subtract(a: float, b: float, *, dims: tuple[int, int] | None = None) -> float: ...
@overload
def subtract(a: float, b: VectorLike, *, dims: tuple[int, int] | None = None) -> Vector: ...
@overload
def subtract(a: VectorLike, b: float, *, dims: tuple[int, int] | None = None) -> Vector: ...
@overload
def subtract(a: float, b: MatrixLike, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def subtract(a: MatrixLike, b: float, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def subtract(a: VectorLike, b: VectorLike, *, dims: tuple[int, int] | None = None) -> Vector: ...
@overload
def subtract(a: VectorLike, b: MatrixLike, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def subtract(a: MatrixLike, b: VectorLike, *, dims: tuple[int, int] | None = None) -> Matrix: ...
@overload
def subtract(a: MatrixLike, b: MatrixLike, *, dims: tuple[int, int] | None = None) -> Matrix: ...

class BroadcastTo:
    data: Incomplete
    shape: Incomplete
    different: Incomplete
    amount: Incomplete
    length: Incomplete
    repeat: Incomplete
    expand: Incomplete
    def __init__(self, array: ArrayLike, old: tuple[int, ...], new: tuple[int, ...]) -> None: ...
    def reset(self) -> None: ...
    def __next__(self) -> float: ...
    def __iter__(self) -> Iterator[float]: ...

class Broadcast:
    iters: Incomplete
    shape: Incomplete
    ndims: Incomplete
    size: Incomplete
    def __init__(self, *arrays: ArrayLike) -> None: ...
    def reset(self) -> None: ...
    def __next__(self) -> tuple[float, float]: ...
    def __iter__(self) -> Broadcast: ...

def broadcast(*arrays: ArrayLike) -> Broadcast: ...
def broadcast_to(a: ArrayLike, s: int | Sequence[int]) -> Array: ...
def full(array_shape: int | Sequence[int], fill_value: float | ArrayLike) -> Array: ...
def ones(array_shape: int | Sequence[int]) -> Array: ...
def zeros(array_shape: int | Sequence[int]) -> Array: ...
def identity(size: int) -> Matrix: ...
def flatiter(array: float | ArrayLike) -> Iterator[float]: ...
def ravel(array: float | ArrayLike) -> Vector: ...
def arange(start: SupportsFloatOrInt, stop: SupportsFloatOrInt | None = None, step: SupportsFloatOrInt = 1) -> Vector: ...
@overload
def transpose(array: VectorLike) -> Vector: ...
@overload
def transpose(array: Matrix) -> Matrix: ...
def reshape(array: ArrayLike, new_shape: int | Sequence[int]) -> float | Array: ...
def shape(array: float | ArrayLike) -> tuple[int, ...]: ...
def fill_diagonal(matrix: MatrixLike, val: float | ArrayLike = 0.0, wrap: bool = False) -> None: ...
def eye(n: int, m: int | None = None, k: int = 0) -> Matrix: ...
@overload
def diag(array: VectorLike, k: int = 0) -> Matrix: ...
@overload
def diag(array: Matrix, k: int = 0) -> Vector: ...
def inv(matrix: MatrixLike) -> Matrix: ...
def vstack(arrays: tuple[ArrayLike, ...]) -> Array: ...
def hstack(arrays: tuple[ArrayLike, ...]) -> Array: ...
def outer(a: float | ArrayLike, b: float | ArrayLike) -> Matrix: ...
def inner(a: float | ArrayLike, b: float | ArrayLike) -> float | Array: ...
