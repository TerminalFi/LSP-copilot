from ..channels import Channel as Channel
from ..color import Color as Color
from ..css import serialize as serialize
from ..types import Plugin as Plugin, Vector as Vector, VectorLike as VectorLike
from _typeshed import Incomplete
from abc import ABCMeta, abstractmethod
from typing import Any

class Cylindrical:
    def hue_name(self) -> str: ...
    def hue_index(self) -> int: ...

class Labish:
    def labish_names(self) -> tuple[str, ...]: ...
    def labish_indexes(self) -> list[int]: ...

class LChish(Cylindrical):
    def lchish_names(self) -> tuple[str, ...]: ...
    def lchish_indexes(self) -> list[int]: ...

alpha_channel: Incomplete

class SpaceMeta(ABCMeta):
    def __init__(cls, name: str, bases: tuple[object, ...], clsdict: dict[str, Any]) -> None: ...

class Space(Plugin, metaclass=SpaceMeta):
    BASE: str
    NAME: str
    SERIALIZE: tuple[str, ...]
    CHANNELS: tuple[Channel, ...]
    CHANNEL_ALIASES: dict[str, str]
    COLOR_FORMAT: bool
    GAMUT_CHECK: str | None
    EXTENDED_RANGE: bool
    WHITE: Incomplete
    channels: Incomplete
    def __init__(self, **kwargs: Any) -> None: ...
    def get_channel_index(self, name: str) -> int: ...
    @classmethod
    def white(cls) -> VectorLike: ...
    @abstractmethod
    def to_base(self, coords: Vector) -> Vector: ...
    @abstractmethod
    def from_base(self, coords: Vector) -> Vector: ...
    def to_string(self, parent: Color, *, alpha: bool | None = None, precision: int | None = None, fit: bool | str = True, none: bool = False, **kwargs: Any) -> str: ...
    def normalize(self, coords: Vector) -> Vector: ...
    def match(self, string: str, start: int = 0, fullmatch: bool = True) -> tuple[tuple[Vector, float], int] | None: ...
