import abc
from . import compositing as compositing, contrast as contrast, convert as convert, distance as distance, filters as filters, gamut as gamut, harmonies as harmonies, interpolate as interpolate, util as util
from .cat import Bradford as Bradford, CAT as CAT
from .contrast import ColorContrast as ColorContrast
from .contrast.wcag21 import WCAG21Contrast as WCAG21Contrast
from .css import parse as parse
from .distance import DeltaE as DeltaE
from .distance.delta_e_2000 import DE2000 as DE2000
from .distance.delta_e_76 import DE76 as DE76
from .distance.delta_e_94 import DE94 as DE94
from .distance.delta_e_cmc import DECMC as DECMC
from .distance.delta_e_hyab import DEHyAB as DEHyAB
from .distance.delta_e_ok import DEOK as DEOK
from .filters import Filter as Filter
from .filters.cvd import Deutan as Deutan, Protan as Protan, Tritan as Tritan
from .filters.w3c_filter_effects import Brightness as Brightness, Contrast as Contrast, Grayscale as Grayscale, HueRotate as HueRotate, Invert as Invert, Opacity as Opacity, Saturate as Saturate, Sepia as Sepia
from .gamut import Fit as Fit
from .gamut.fit_lch_chroma import LChChroma as LChChroma
from .gamut.fit_oklch_chroma import OkLChChroma as OkLChChroma
from .interpolate import Interpolate as Interpolate, Interpolator as Interpolator
from .interpolate.bspline import BSpline as BSpline
from .interpolate.bspline_natural import NaturalBSpline as NaturalBSpline
from .interpolate.linear import Linear as Linear
from .interpolate.monotone import Monotone as Monotone
from .spaces import Cylindrical as Cylindrical, Space as Space
from .spaces.a98_rgb import A98RGB as A98RGB
from .spaces.a98_rgb_linear import A98RGBLinear as A98RGBLinear
from .spaces.display_p3 import DisplayP3 as DisplayP3
from .spaces.display_p3_linear import DisplayP3Linear as DisplayP3Linear
from .spaces.hsl.css import HSL as HSL
from .spaces.hsv import HSV as HSV
from .spaces.hwb.css import HWB as HWB
from .spaces.lab.css import Lab as Lab
from .spaces.lab_d65 import LabD65 as LabD65
from .spaces.lch.css import LCh as LCh
from .spaces.lch_d65 import LChD65 as LChD65
from .spaces.oklab.css import Oklab as Oklab
from .spaces.oklch.css import OkLCh as OkLCh
from .spaces.prophoto_rgb import ProPhotoRGB as ProPhotoRGB
from .spaces.prophoto_rgb_linear import ProPhotoRGBLinear as ProPhotoRGBLinear
from .spaces.rec2020 import Rec2020 as Rec2020
from .spaces.rec2020_linear import Rec2020Linear as Rec2020Linear
from .spaces.srgb.css import sRGB as sRGB
from .spaces.srgb_linear import sRGBLinear as sRGBLinear
from .spaces.xyz_d50 import XYZD50 as XYZD50
from .spaces.xyz_d65 import XYZD65 as XYZD65
from .types import ColorInput as ColorInput, Plugin as Plugin, Vector as Vector, VectorLike as VectorLike
from _typeshed import Incomplete
from typing import Any, Callable, Mapping, Sequence, overload

class ColorMatch:
    color: Incomplete
    start: Incomplete
    end: Incomplete
    def __init__(self, color: Color, start: int, end: int) -> None: ...

class ColorMeta(abc.ABCMeta):
    def __init__(cls, name: str, bases: tuple[object, ...], clsdict: dict[str, Any]) -> None: ...

class Color(metaclass=ColorMeta):
    CS_MAP: dict[str, Space]
    DE_MAP: dict[str, DeltaE]
    FIT_MAP: dict[str, Fit]
    CAT_MAP: dict[str, CAT]
    CONTRAST_MAP: dict[str, ColorContrast]
    FILTER_MAP: dict[str, Filter]
    INTERPOLATE_MAP: dict[str, Interpolate]
    PRECISION: Incomplete
    FIT: Incomplete
    INTERPOLATE: Incomplete
    DELTA_E: Incomplete
    HARMONY: Incomplete
    CHROMATIC_ADAPTATION: str
    CONTRAST: str
    def __init__(self, color: ColorInput, data: VectorLike | None = None, alpha: float = ..., **kwargs: Any) -> None: ...
    def __len__(self) -> int: ...
    @overload
    def __getitem__(self, i: str | int) -> float: ...
    @overload
    def __getitem__(self, i: slice) -> Vector: ...
    @overload
    def __setitem__(self, i: str | int, v: float) -> None: ...
    @overload
    def __setitem__(self, i: slice, v: Vector) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    @classmethod
    def match(cls, string: str, start: int = 0, fullmatch: bool = False) -> ColorMatch | None: ...
    @classmethod
    def register(cls, plugin: Plugin | Sequence[Plugin], *, overwrite: bool = False, silent: bool = False) -> None: ...
    @classmethod
    def deregister(cls, plugin: str | Sequence[str], *, silent: bool = False) -> None: ...
    @classmethod
    def random(cls, space: str, *, limits: Sequence[Sequence[float] | None] | None = None) -> Color: ...
    def to_dict(self) -> Mapping[str, Any]: ...
    def normalize(self) -> Color: ...
    def is_nan(self, name: str) -> bool: ...
    def space(self) -> str: ...
    def new(self, color: ColorInput, data: VectorLike | None = None, alpha: float = ..., **kwargs: Any) -> Color: ...
    def clone(self) -> Color: ...
    def convert(self, space: str, *, fit: bool | str = False, in_place: bool = False) -> Color: ...
    def mutate(self, color: ColorInput, data: VectorLike | None = None, alpha: float = ..., **kwargs: Any) -> Color: ...
    def update(self, color: Color | str | Mapping[str, Any], data: VectorLike | None = None, alpha: float = ..., **kwargs: Any) -> Color: ...
    def to_string(self, **kwargs: Any) -> str: ...
    def white(self) -> Vector: ...
    def uv(self, mode: str = '1976') -> Vector: ...
    def xy(self) -> Vector: ...
    @classmethod
    def chromatic_adaptation(cls, w1: tuple[float, float], w2: tuple[float, float], xyz: VectorLike, *, method: str | None = None) -> Vector: ...
    def clip(self, space: str | None = None) -> Color: ...
    def fit(self, space: str | None = None, *, method: str | None = None, **kwargs: Any) -> Color: ...
    def in_gamut(self, space: str | None = None, *, tolerance: float = ...) -> bool: ...
    def mask(self, channel: str | Sequence[str], *, invert: bool = False, in_place: bool = False) -> Color: ...
    def mix(self, color: ColorInput, percent: float = ..., *, in_place: bool = False, **interpolate_args: Any) -> Color: ...
    @classmethod
    def steps(cls, colors: Sequence[ColorInput | interpolate.stop | Callable[..., float]], *, steps: int = 2, max_steps: int = 1000, max_delta_e: float = 0, delta_e: str | None = None, **interpolate_args: Any) -> list['Color']: ...
    @classmethod
    def interpolate(cls, colors: Sequence[ColorInput | interpolate.stop | Callable[..., float]], *, space: str | None = None, out_space: str | None = None, progress: Mapping[str, Callable[..., float]] | Callable[..., float] | None = None, hue: str = ..., premultiplied: bool = True, extrapolate: bool = False, method: str = 'linear', **kwargs: Any) -> Interpolator: ...
    def filter(self, name: str, amount: float | None = None, *, space: str | None = None, in_place: bool = False, **kwargs: Any) -> Color: ...
    def harmony(self, name: str, *, space: str | None = None) -> list['Color']: ...
    def compose(self, backdrop: ColorInput | Sequence[ColorInput], *, blend: str | bool = True, operator: str | bool = True, space: str | None = None, out_space: str | None = None, in_place: bool = False) -> Color: ...
    def delta_e(self, color: ColorInput, *, method: str | None = None, **kwargs: Any) -> float: ...
    def distance(self, color: ColorInput, *, space: str = 'lab') -> float: ...
    def closest(self, colors: Sequence[ColorInput], *, method: str | None = None, **kwargs: Any) -> Color: ...
    def luminance(self) -> float: ...
    def contrast(self, color: ColorInput, method: str | None = None) -> float: ...
    def get(self, name: str) -> float: ...
    def set(self, name: str, value: float | Callable[..., float]) -> Color: ...
