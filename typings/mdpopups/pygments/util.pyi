from _typeshed import Incomplete
from io import BytesIO as BytesIO, StringIO as StringIO, TextIOWrapper

split_path_re: Incomplete
doctype_lookup_re: Incomplete
tag_re: Incomplete
xml_decl_re: Incomplete

class ClassNotFound(ValueError): ...
class OptionError(Exception): ...

def get_choice_opt(options, optname, allowed, default: Incomplete | None = None, normcase: bool = False): ...
def get_bool_opt(options, optname, default: Incomplete | None = None): ...
def get_int_opt(options, optname, default: Incomplete | None = None): ...
def get_list_opt(options, optname, default: Incomplete | None = None): ...
def docstring_headline(obj): ...
def make_analysator(f): ...
def shebang_matches(text, regex): ...
def doctype_matches(text, regex): ...
def html_doctype_matches(text): ...
def looks_like_xml(text): ...
def unirange(a, b): ...
def format_lines(var_name, seq, raw: bool = False, indent_level: int = 0): ...
def duplicates_removed(it, already_seen=()): ...

class Future:
    def get(self) -> None: ...

def guess_decode(text): ...
def guess_decode_from_terminal(text, term): ...
def terminal_encoding(term): ...
unichr = chr
xrange = range
string_types: Incomplete
text_type = str
u_prefix: str
iteritems: Incomplete
itervalues: Incomplete

class UnclosingTextIOWrapper(TextIOWrapper):
    def close(self) -> None: ...

def add_metaclass(metaclass): ...
