import subprocess
from .helpers import SemanticVersion
from .third_party.semantic_version import NpmSpec, Version
from LSP.plugin.core.typing import Any, Dict, List, Optional, Tuple, Union
from _typeshed import Incomplete

__all__ = ['NodeRuntime']

class NodeRuntime:
    _node_runtime_resolved: bool
    _node_runtime: Incomplete
    @classmethod
    def get(cls, package_name: str, storage_path: str, required_node_version: Union[str, SemanticVersion]) -> Optional['NodeRuntime']: ...
    @classmethod
    def _resolve_node_runtime(cls, package_name: str, storage_path: str, required_node_version: NpmSpec) -> NodeRuntime: ...
    _node: Incomplete
    _npm: Incomplete
    _version: Incomplete
    _additional_paths: Incomplete
    def __init__(self) -> None: ...
    def __repr__(self) -> str: ...
    def install_node(self) -> None: ...
    def node_bin(self) -> Optional[str]: ...
    def npm_bin(self) -> Optional[str]: ...
    def node_env(self) -> Dict[str, str]: ...
    def check_binary_present(self) -> None: ...
    def check_satisfies_version(self, required_node_version: NpmSpec) -> None: ...
    def resolve_version(self) -> Version: ...
    def run_node(self, args: List[str], stdin: int = ..., stdout: int = ..., stderr: int = ..., env: Dict[str, Any] = {}) -> Optional['subprocess.Popen[bytes]']: ...
    def run_install(self, cwd: str) -> None: ...
    def npm_command(self) -> List[str]: ...

class NodeRuntimePATH(NodeRuntime):
    _node: Incomplete
    _npm: Incomplete
    def __init__(self) -> None: ...

class NodeRuntimeLocal(NodeRuntime):
    _base_dir: Incomplete
    _node_version: Incomplete
    _node_dir: Incomplete
    _install_in_progress_marker_file: Incomplete
    def __init__(self, base_dir: str, node_version: str = ...) -> None: ...
    def npm_command(self) -> List[str]: ...
    def install_node(self) -> None: ...
    _node: Incomplete
    _node_lib: Incomplete
    _npm: Incomplete
    _additional_paths: Incomplete
    def _resolve_paths(self) -> None: ...
    def _resolve_binary(self) -> Optional[str]: ...
    def _resolve_lib(self) -> str: ...

class NodeInstaller:
    _base_dir: Incomplete
    _node_version: Incomplete
    _cache_dir: Incomplete
    def __init__(self, base_dir: str, node_version: str = ...) -> None: ...
    def run(self) -> None: ...
    def _node_archive(self) -> Tuple[str, str]: ...
    def _archive_exists(self, filename: str) -> bool: ...
    def _download_node(self, url: str, filename: str) -> None: ...
    def _install_node(self, filename: str) -> None: ...

class ElectronRuntimeLocal(NodeRuntime):
    _base_dir: Incomplete
    _yarn: Incomplete
    _install_in_progress_marker_file: Incomplete
    def __init__(self, base_dir: str) -> None: ...
    def node_env(self) -> Dict[str, str]: ...
    def install_node(self) -> None: ...
    def run_install(self, cwd: str) -> None: ...
    _node: Incomplete
    _npm: Incomplete
    def _resolve_paths(self) -> None: ...
    def _resolve_binary(self) -> Optional[str]: ...
    def _run_yarn(self, args: List[str], cwd: str) -> None: ...

class ElectronInstaller:
    _base_dir: Incomplete
    _cache_dir: Incomplete
    def __init__(self, base_dir: str) -> None: ...
    def run(self) -> None: ...
    def _node_archive(self) -> Tuple[str, str]: ...
    def _archive_exists(self, filename: str) -> bool: ...
    def _download(self, url: str, filename: str) -> None: ...
    def _install(self, filename: str) -> None: ...
    def _download_yarn(self) -> None: ...
